/*
 * Example for DBrew vectorization API
 */

#include "dbrew.h"

#include <sys/time.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>

typedef void (*vcopy_t)(double*, double*, int);
typedef void (*vadd_t)(double*, double*, double*, int);

// vcopy

double copy_kernel(double v)
{
    return v;
}

void vcopy(double* dst, double* src, int n)
{
    while(n>4) {
        dbrew_apply4_R8V8(copy_kernel, dst, src);
        dst += 4;
        src += 4;
        n -= 4;
    }
    while(n>0) {
        *dst++ = *src++;
        n--;
    }
}


// vadd

double add_kernel(double v1, double v2)
{
    return v1 + v2;
}

void vadd(double* dst, double* src1, double* src2, int n)
{
    while(n>4) {
        dbrew_apply4_R8V8V8(add_kernel, dst, src1, src2);
        dst += 4;
        src1 += 4;
        src2 += 4;
        n -= 4;
    }
    while(n>0) {
        *dst++ = add_kernel(*src1++, *src2++);
        n--;
    }
}


double wtime()
{
  struct timeval tv;
  gettimeofday(&tv, 0);

  return tv.tv_sec+1e-6*tv.tv_usec;
}

// for decoding code generated by rewriting
void decode_func(Rewriter* r, const char* n)
{
    Rewriter* rr = dbrew_new();
    uint64_t func = dbrew_generated_code(r);
    int size = dbrew_generated_size(r);
    dbrew_config_function_setname(rr, func, n);
    dbrew_config_function_setsize(rr, func, size);
    dbrew_decode_print(rr, func, size);
    dbrew_free(rr);
}


int main(int argc, char* argv[])
{
    double t1, t2, t3, t4;
    int arg = 1, len = 0, iters = 0, verb = 0, run = 1;
    if ((argc>arg) && (strcmp(argv[arg],"-v")==0)) { verb++; arg++; }
    if ((argc>arg) && (strcmp(argv[arg],"-v")==0)) { verb++; arg++; }
    if ((argc>arg) && (strcmp(argv[arg],"-n")==0)) { run = 0; arg++; }
    if (argc>arg) { len   = atoi(argv[arg]); arg++; }
    if (argc>arg) { iters = atoi(argv[arg]); arg++; }
    if (len == 0) len = 10000;
    if (iters == 0) iters = 100;
    len = len * 1000;

    printf("Alloc/init 3 double arrays of length %d ...\n", len);
    double* a = (double*) malloc(len * sizeof(double));
    double* b = (double*) malloc(len * sizeof(double));
    double* c = (double*) malloc(len * sizeof(double));
    for(int i = 0; i<len; i++) {
        a[i] = 1.0;
        b[i] = 2.0;
        c[i] = 3.0;
    }

    // Gnerate vectorized variants & run against naive/original

    Rewriter* r1 = dbrew_new();
    if (verb>1) dbrew_verbose(r1, true, true, true);
    dbrew_set_function(r1, (uint64_t) vcopy);
    dbrew_config_parcount(r1, 3);
    dbrew_config_force_unknown(r1, 0);
    vcopy_t vcopy2 = (vcopy_t) dbrew_rewrite(r1, a, b, len);
    if (verb) decode_func(r1, "vcopy2");

    printf("Running %d iterations of vcopy ...\n", iters);
    t1 = wtime();
    for(int iter = 0; iter < iters; iter++) {
        b[0] = (double) iter; // prohibit loop exchange
        for(int i = 0; i < len; i++)
            a[i] = b[i];
    }
    t2 = wtime();
    for(int iter = 0; iter < iters; iter++)
        vcopy(a, b, len);
    t3 = wtime();
    if (run)
        for(int iter = 0; iter < iters; iter++)
            vcopy2(a, b, len);
    t4 = wtime();
    printf("  naive: %.3f s, un-rewritten: %.3f s, rewritten: %.3f s\n",
           t2-t1, t3-t2, t4-t3);

    Rewriter* r2 = dbrew_new();
    if (verb>1) dbrew_verbose(r2, true, true, true);
    dbrew_set_function(r2, (uint64_t) vadd);
    dbrew_config_parcount(r2, 4);
    dbrew_config_force_unknown(r2, 0);
    vadd_t vadd2 = (vadd_t) dbrew_rewrite(r2, a, b, c, len);
    if (verb) decode_func(r2, "vadd2");

    printf("Running %d iterations of vadd ...\n", iters);
    t1 = wtime();
    for(int iter = 0; iter < iters; iter++) {
        b[0] = (double) iter; // prohibit loop exchange
        for(int i = 0; i < len; i++)
            a[i] = b[i] + c[i];
    }
    t2 = wtime();
    for(int iter = 0; iter < iters; iter++)
        vadd(a, b, c, len);
    t3 = wtime();
    if (run)
        for(int iter = 0; iter < iters; iter++)
            vadd2(a, b, c, len);
    t4 = wtime();
    printf("  naive: %.3f s, un-rewritten: %.3f s, rewritten: %.3f s\n",
           t2-t1, t3-t2, t4-t3);
}
