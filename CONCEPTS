Various Ideas/Concepts
======================


Addressing Modes with register indirection/scaling (ModRM/SIB)
----

We can 'flatten' the address expression for simplifying the
ISA subset used for capturing, and catch the pattern to generate
instructions with complex addressing in the end.

Is it worth it?
It may make optimization passes simpler. We could simplify captured
instructions by converting operands with memory access to own mov
instructions (RISC-like load/store architecture).
But this needs temporary registers, and complex pattern matching.



Detection of Stack Accesses
----

Problem:
To maintain static/dynamic metainfo for data on the stack,
we need to know the address to tell the offset within the stack. This
is not straight-forward, as accesses are done by register-relative
addressing, and addresses may change between multiple invocations of
the captured code.

Solution:
Maintain a new meta-info about whether a value is a fixed offset
from the stack pointer (%rsp) at capture start, which also is the
offset from top of our stack. That is, we need to maintain the offset.

Generalization:
We could maintain the information if a value has a fixed difference from
another value (ie. whether it was derived from it with constant changes).
If so, we could reconstruct the value from the original.

Subproblem:
What to do if the stack pointer is modified by an unknown amount (but
in growing directio!), e.g. on alloca()? We still want to maintain the
static/dynamic state of a value pushed and pop'ped afterwards.

Solution (?): after the unknown change, remember the new stack value,
start a new stack, and maintain the distance. This needs versioning of
stack pointer and stack itself. Can we "garbage collect" such new
stacks during capturing? Probably not needed.



Fast Code Generator
---

* do not do complete unrolling at capture time, but record the
  fact that we should do it, for delaying that to the code generator
* can we do this by capturing a loop with e.g. 3 iterations for
  a generic code generator with N iterations?


Loops
----

If we branch depending on dynamic state, we need to trace both
paths, as the generated code may be called with data going either way.
We can call the branch our emulator wants to go the main path, and
the other(s) ghost paths.
We first go the main path, and remember dynamic branches on the way
on a stack (with the complete emulator state) to allow for backtracking
with state rollback to also capture all ghost paths.

When capturing a BB, we mark it with a label and the capture state of
the emulator. If we revisit the BB from a dynamic branch, we check for
matching capture state. If the capture states do not match, we may
(1) start another capturing of this BB, or (2) change static to dynamic states
(by updating the register/stack element with the static data) to align the
capture states before jumping to an already captured BB version.
(Does this also need to check for liveness matching/call depth matching?).

After a branch depending on a dynamic flag, this flag can be set to static.
To get further static information, we can track back the reason which
resulted in the flag value. This needs remembering how the flag was
calculated. E.g. with "CMP rax, 0; BEQ <eq>", we know that rax has
static value 0 on <eq> path.
