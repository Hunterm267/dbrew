Binary Specialization
=====================

Goals:
* low-level functionality for binary code modification at runtime:
  library, independent on programming language (but on processor ISA)
* composition of concepts via abstractions without performance
  penalties, using partial evalution/specialisation

* optimizations which demonstrate benefits
  - inlining of libc functions (removing function call overhead)
  - specialization/partial evaluation: take advantage of values known

Approach:
* use function call interface/calling convention to influence generator
* code generation by following emulator executing other code
* use generator request struct to specify actions

Wanted features:
* x86_64/Linux
* mark function parameters as constant for specialization (DONE)
* hooks for memory accesses, ...
* generation of new code: replace/insert/remove function calls/wrappers
* dynamic detection of data region overlapping (conflicts/dependencies/PGAS)
* dynamic locality optimization: reorder execution, generate conversions
* dynamic prefetch insertion
* allow multi-staging: capturing returns parametrized macros for patching
  as resulting data structure (macros = binary templates), allows to
  generate a fast generator
* allow PGAS abstractions implemented with MPI
* data access remapping
* explicit/implicit code management
* external to binary (LD_PRELOAD + breakpoint handler, config file)
* NOT: make it type-safe

Open questions:
* need for Pin-like API? (hook for each instruction/memory access/...)
* config via function calls enough to reimplement Valgrind/Pin tools?
* how to add cache optimization/tiling strategies?
* persistent code (generate into object files/shared libs?)
* how to help for (better) SIMD code ?
* for GPU: PTX/SPIR ?
* usable for meta-tracing compilation? (trace interpreter)
* Best interface for C++? Instead of templates, use specialized
  polymorphism, ie. VTables get replaced by inlining methods of known type

Show case:
* 2D Jacobi
  * stencil specified as arbitrary function
  * include 2D looping with variable with/height, but border handling
  * capture border and generate pack/unpack handler for MPI
  * ...
* Arbitrary MPI-parallelized stencil
  * element type variable (multiple attributes per grid element)
  * arbitrary memory layout order
  * 2D/3D
  * Tuning for Cache: Blocking/Wavefront by abstraction: n sweeps over all
  * Borders: access into message buffers/create messages with traversal
* Cache-oblivious algorithm?


Prototype
=========

Capturing
* const-ness for parameters for specialization
* influence capturing/code generation
  * keep call to given function in generated code
  * hook to call for remapping memory access


Example driven implementation
* simple example: add two integers
  * binary x86_64 parser (DONE)
  * binary emulator (DONE)
  * binary re-generator (DONE)
  * (nested) specialization of parameters (DONE)
* loop example: with variable/fixed loop count, special code for ranges
  * complete unrolling
  * fixed factor unrolling (how to specify?)
  * series of subloops for ranges
* SPMV with sparse matrix structure from input file
* fast code generator using parametrized capture result a+x, patching x


Tasks/Todo
* Test suite to cover
  * implemented instructions (parser/generator)
  * calling convention (different number/types of parameters)
  * all types of specialization transformations
* ISA coverage
  * examples
  * x86_64 base
  * x87, SSE, AVX, AVX512
* code generator
  * control flow support: needs relocation (RIP-relative bug)
  * register re-allocation: live-ness analysis of registers/stack frame
    - benefits: avoid spilling, save/restore, prolog/epilog
    - easier by maintaining a virtual register mapping in emulation?
  * "if": state gets known in if/else path



Students Work
=============

MA Theses
* Extend Parser/Emulator/Specializer for 2D Jacobi show case,
  with control flow support, register-reallocation
* rewrite to add tags to pointers (dynamic assertions)
* PGAS abstractions as library
  (domains, affinity mappings, iteration order, partitioning)
* adaptive prefetching (assuming prefetcher model, extension for MIC)
  + data structure reordering for better hardware prefetching
* fast code generator using dynamically generated templates & patching
* LLVM-IR generation
* re-implement simple tool from Valgrind/Pin

BA Theses
* Extend ISA coverage, test suite
* SPMV: comparison with compiled code


Related Work
============

Specialisation on Language Level

- Multi-Staging (Scala, ...)
- AnyDSL
- Intel Array Building Blocks

Tracing JITters

- TraceMonkey (Gal: Trace Trees)
- Boltz/Tratt: The Impact of Meta-Tracing on VM Design and Implementation
  RPhyton: tracing JIT automatically guided by interpreteri
- Marr/Ducasse: Tracing vs. Partial Evaluation: Comparing
  Meta-Compilation Approaches

Multi-Architecture Optimization

- AnyDSL
- Discussion on HN (https://news.ycombinator.com/item?id=10032295):
  we want automatic tuning on binary level
  